---
layout: post
title: "Singleton Pattern(싱글톤 패턴)"
description: "Singleton Pattern(싱글톤 패턴)"
date: 2019-04-08
tags: [싱글톤 패턴]
comments: true
share: true
---

#### Singleton Pattern(싱글톤 패턴)
* 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴이다.
* Spring Bean
* 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.
* 자바에서는 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 한다.
* 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다.
* 인스턴스가 필요 할 때 똑같은 인스턴스를 만들어 내는 것이 아니라, 동일(기존) 인스턴스를 사용하게 한다.

#### 싱글톤 패턴을 쓰는 이유
* 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있다.
* 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.
* DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러 개 생성해서 사용해야 하는 상황에서 많이 사용한다.
* 스레드 풀, 캐시, 대화 상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등
* 인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶을 경우에 사용한다.
* 두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아진다.

#### 문제점
* 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 "개방-폐쇄 원칙"을 위배하게 된다.(객체 지향 설계 원칙에 어긋난다.)
* 수정이 어려워지고 테스트하기 어려워진다.
* 멀티 스레드 환경에서 동기화 처리를 안하면 인스턴스가 두개가 생성된다던지 하는 경우가 발생할 수 있다.

#### 멀티 스레드에서 Thread-safe한 싱글톤 클래스, 인스턴스 만드는 방법

##### 1.Thread safe Lazy Initialization(게으른 초기화)
* private static으로 인스턴스 변수를 만들고 private 생성자로 외부에서 생성을 막았다.

* synchronized 키워드를 사용해서 thread-safe 하게 만들었다.

* synchronized 특성상 비교적 큰 성능 저하가 발생한다.

* 권장 하는 방법이 아니다.

* ```java
  public class ThreadSafeLazyInitialization{
   
      private static ThreadSafeLazyInitialization instance;
   
      private ThreadSafeLazyInitialization(){}
       
      public static synchronized ThreadSafeLazyInitialization getInstance(){
          if(instance == null){
              instance = new ThreadSafeLazyInitialization();
          }
          return instance;
      }
   
  }
  ```

##### 2.Thread safe Lazy Initialization + Double Checked Locking
* 게으른 초기화의 성능 저하를 완화시키는 방법

* getInstance()에 synchronized를 사용하는 것이 아니라 첫 번째 if문으로 인스턴스의 존재 여부를 체크 하고 두 번째 if문에서 다시 한번 체크할 때 동기화 시켜서 인스턴스를 생성하므로 thread-safe하다.

* 처음 생성 이후에 synchonized 블럭을 타지 않기 때문에 성능 저하를 완화했다.

* 완벽한 방법은 아니다.

* ```java
  public class ThreadSafeLazyInitialization {
   
      private volatile static ThreadSafeLazyInitialization instance;
   
      private ThreadSafeLazyInitialization(){}
       
      public static ThreadSafeLazyInitialization getInstance(){
          
          if(instance == null){
              synchronized (ThreadSafeLazyInitialization.class) {
                  if(instance == null)
                      instance = new ThreadSafeLazyInitialization();
              }
   
          }
          return instance;
      }
  }
  ```
  
##### 3.Initialization on demand holder idiom(holder에 의한 초기화)
* 클래스 안에 클래스(Holder)를 두어 JVM의 Class Loader 매커니즘과 Class가 로드되는 시점을 이용한 방법이다.

* JVM 클래스 초기화 과정에서 보장되는 원자적 특성을 이용하여 싱글톤 초기화 문제에 대한 책임을 JVM에게 떠넘긴다.

* holder 안에 선언된 instance가 static이기 때문에 클래스 로딩 시점에 한번만 호출될 것이며 final을 사용해 다시 값이 할당되지 않도록 만든 방법이다.

* 가장 많이 사용하고 일반적인 싱글콘 클래스 사용 방법이다.

* ```java
  public class Something {
      private Something() {
      }
   
      private static class LazyHolder {
          public static final Something INSTANCE = new Something();
      }
   
      public static Something getInstance() {
          return LazyHolder.INSTANCE;
      }
  }
  ```