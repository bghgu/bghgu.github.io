---
layout: post
title: "Java Virtual Machine(JVM, 자바 가상 머신)"
description: "Java Virtual Machine(JVM, 자바 가상 머신)"
date: 2019-04-05
tags: [자바]
comments: true
share: true
---

#### JVM
* 자바 가상 머신
* 자바 애플리케이션을 Class Loader를 통해 읽어 들여 자바 API와 함께 실행하는 것이다.
* JVM은 자바와 운영체제 사이에서 중개자 역할을 수행하여 자바가 운영체제에 구해받지 않고 재사용을 가능하게 해 준다.
* `메모리 관리`, `Garbage Collection`을 수행한다.
* `Stack 기반의 가상 머신`으로 대다수의 명령어가 Stack 선두에서 피 연산자를 택하고 다시 Stack에 넣는다.
* 자바 바이트 코드를 실행할 수 있는 주체이다.
* Interpreter나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
* JVM은 플랫폼에 독립적이다.
* 이론적으로 모든 자바 프로그램은 CPU가 운영체제의 종류와 무관하게 동작할 것을 보장한다.
* 포인터를 지원하지만 C처럼 주소 값을 임의로 조작이 가능한 포인터 연산을 지원하지 않는다.
* Garbage Collection을 사용해 메모리(자원)를 관리한다.
* `Class Loader`, `Runtime Data Areas`, `Execution Engine` 3가지로 구성되어 있다.

#### 실행 과정
1. 자바 애플리케이션이 실행되면 JVM은 운영체제로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. Javac 컴파일러가 자바 소스코드(.java)를 읽어 들여 자바 바이트 코드(.class)로 변환시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 Loading(적재)한다.
4. Loading(적재)된 class 파일들은 Execution Engine을 통해 해석된다.
5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 된다.
6. 이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC 같은 관리 작업을 수행한다.

#### Class Loader
* Rumtime 시점에 동적으로 클래스를 Loading하게 해준다.
* 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리(Runtime Data Area)에 로드하게 된다.
* .jar 파일 내 저장된 클래스들을 JVM 위에 탑재하고, 사용하지 않는 클래스들은 메모리에서 삭제한다.
* 자바는 동적 코드다. 컴파일시가 아니라 런타임시에 참조한다. 즉 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크한다.
* Loading -> Linking -> Initialization

##### Loader
* 목적 프로그램(기계어 파일)을 실행 가능한 파일로 변환하기 위해 컴퓨터의 주 기억 장치를 할당(Allocation)하거나, 여러 개의 목적 프로그램을 연계 편집하여 CPU가 처리할 수 있는 프로그램으로 변환시킨다.
* 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 주 기억 장치에 올려 놓는 작업을 수행한다.
* 목적 프로그램들 끼리 연결(Linking)시키거나, 주 기억 장치를 재배치(Relocation)하는 등 포괄적인 작업을 수행한다.
* 할당(Allocation) -> 연결(Linking) -> 재배치(Relocation) -> 적재(Loading) 순으로 진행된다.

#### Runtime Data Areas
* 프로그램을 수행하기 위해 운영체제에서 할당받은 메모리 공간

##### 1. PC Register
* 현재 수행중인 JVM 명령어의 주소를 가진다.
* 스레드가 어떤 명령어도 실행되어야 할지에 대한 기록을 하는 부분이다.
* 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.

##### 2. JVM Stack
* 프로그램 실행 과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
* 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장한다.
* 메소드 호출시마다 각각의 스택 프레임(그 메소드만을 위한 공간)이 생성된다.
* 메소드 수행이 끝나면 프레임별로 삭제를 진행한다.
* 재귀함수보다는 반복문이 더 빠른 이유다.
* 메소드 안에서 사용되는 지역 변수(Local  Variable)을 저장한다.
* 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.
* 각 스레드마다 하나씩 생성된다.
* JVM은 오직 JVM 스택에 스택 프레임을 추가하고 제거하는 동작만 수행한다.(Stack - PUSH & POP)
* 예외 발생 시 printStackTrace() 등의 메소드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.

##### 3. Native Method Stack
* 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행 시키는 영역이다.
* 자바가 아닌 다른 언어로 작성된 코드를 위한 영역이다.
* Java Native interface(JNI)를 통해 바이트 코드로 전환하여 저장하게 된다.
* 일반 프로그램처럼 커널이 Stack을 잡아 독자적으로 프로그램을 실행시키는 영역이다.
* 이 부분을 통해 C 코드를 싱행시켜 커널에 접근할 수 있다.
* 각 스레드마다 하나씩 생성된다.
* JNI을 이용하여 JVM 내부에 영향을 주지 않게 하기 위해 Native Method Stack에 새로운 Stack 프레임을 생성하여 추가한다.

##### 4. Method Area, Class Area, Static Area
* 클래스와 인터페이스에 대한 Runtime Constant Pool, 필드와 메소드 코드, Static 변수, final Class 정보, 메소드의 바이트 코드 등이 저장된다.
* 모든 스레드가 공유하는 영역이다
* JVM이 시작될 때 생성된다.
* main 메소드는 static이기 때문에 바로 실행할 수 있다.
* 자바 프로그램은 main 메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어간다.
* Field Information : 멤버변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
* Method Information : 메소드의 이름, 리턴 타입, 매개변수, 접근 제어자에 대한 정보
* Type Information : class인지 interface인지의 여부 저장, type의 속성, 전체 이름, super class의 전체 이름
* 이 공간에 Runtime Constant Pool 이라는 별도의 관리 영역도 함께 존재한다.

##### 5. Runtime Constant Pool
* 각 클래스와 인터페이스의 상수, 매소드와 필드에 대한 모든 참조를 담고 있는 테이블이다.
* 메소드나 필드의 실제 메모리상 주소를 찾을 땐 해당 Pool을 참고한다.

##### 6. Heap Area
* 객체를 저장하는 가상 메모리 공간이다.
* new 연산자로 생성된 객체와 배열을 저장한다.
* class area 영역에 올라온 클래스들만 객체로 생성할 수 있다.
* 프로그램 상에서 런타임시 동적으로 할당하여 사용하는 영역이다.
* 모든 스레드가 공유해서 사용한다.
* GC의 대상이다.

#### Execution Engine
* 클래스를 실행시키는 역할이다.
* 클래스 로더가 JVM 내의 Runtime Data Areas에 바이트 코드를 배치시키고, 이것은 실행 엔진에 의해 실행된다.
* 자바 바이트 코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다.
* 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.
* 인터프리터 방식과 JIT 컴파일러 방식이 있다.

##### Interpreter
* 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
* 한줄 씩 수행하기 때문에 느리다.

##### JIT(Just In Time) Compiler
* 인터프리터 방식의 단점을 보완하기 위해 도입된 컴파일러다.
* 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다.
* 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행된다.
* JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것 보다 훨씬 오래 걸리므로 한번만 실행되는 코드라면 컴파일하지 않고 인터프리팅 하는 것이 유리하다.
* JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넘을 때에만 컴파일을 수행한다.