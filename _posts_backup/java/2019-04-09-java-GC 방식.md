---
layout: post
title: "Java Gargabe Collection 방식"
description: "Java Gargabe Collection"
date: 2019-04-05
tags: [자바]
comments: true
share: true
---

#### Garbage Collection(GC) 4가지

#### Serial GC
* Young 영역의 GC이다.
* 적은 메모리와 CPU 코어 개수가 적을 때 적합한 방식이다.
* Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어진다.
* Mark-Sweep-Compaction을 기준으로 GC를 수행하는 알고리즘이다.
* Mark는 살아있는 객체, GC 대상이 아닌 객체에 대해 식별하는 역할을 한다.
* Sweep는 Heap의 앞 부분부터 살아있는 것만 남긴다.
* Compaction은 각 객체들이 연속되게 쌓이도록 Heap의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 존재하지 않는 부분으로 나눈다.
* GC를 처리하는 스레드가 1개이다.
* 안 쓰는 거 표시해서 삭제하고 한 곳으로 모으는 알고리즘이다.

#### Parallel GC
* CPU가 대기 상태로 남아 있는 것을 최소화한다.
* Young 영역에서의 컬레션을 병렬로 처리한다.
* 많은 CPU를 사용하기 때문에 GC의 부하를 줄이고 애플리케이션의 처리량을 증가시킬 수 있다.
* Serial GC와 기본적인 알고리즘은 같다.
* GC를 처리하는 스레드가 여러개이다. 그렇기 때문에 Serial GC보다 빠르게 객체를 처리할 수 있다.
* 메모리가 충분하고 코어의 개수가 많을 때 유리하다.
* Throughput GC라고도 부른다.
* 여러 CPU를 사용하는 서버에 적합하다.

#### Parallel Compacting Collector
* Parallel GC와 다른 점은 Old 영역 GC에서 새로운 알고리즘을 사용한다.
* Young 영역은 Parallel GC와 동일하다.
* Mark-Summary-Compaction 단계를 거친다.
* Summary 단계는 앞서 GC를 수행한 영역에 대해서 별도로 살아있는 객체를 식별한다.
* Mark-Sweep-Compaction 알고리즘의 Sweep 단계와 다르며 약간 더 복잡한 단계를 거친다.
* Mark 단계 : 살아 있는 객체를 식별해 표시해 놓는 단계
* Sweep 단계 : 이전에 GC를 수행하여 컴팩션된 영역에 살아 있는 객체의 위치를 조사하는 단계
* Compact 단계 : 컴팩션을 수행하는 단계, 수행 이후에는 컴팩션된 영역과 비어있는 영역으로 나뉜다.
* 여러 CPU를 사용하는 서버에 적합하다.

#### Concurrent Mark & Sweep GC (CMS)
* Low-Latency Collector로도 알려져 있다.
* 힙 메로리 영역의 크기가 클 때 적합하다.
* Young 영역에 대한 GC는 Parallel GC와 동일하다.
* Old 영역의 GC
* Mark 단계 : 매우 짧은 대기 시간으로 살아 있는 객체를 찾는 단계
* Sweep 단계 : 서버 수행과 동시에 살아 있는 객체에 표기해 놓는 단계
* Remark 단계 : Concurrent 표시 단계에서 표시하는 동안 변경된 객체에 대해서 다시 표시하는 단계
* Concurrent Sweep 단계 : 표시되어 있는 쓰레기를 정리하는 단계
* 초기 Initial Mark 단계에서는 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝낸다.
* Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인한다.
* 다른 스레드가 실행 중인 상태에서 동시에 진행된다.
* Remark 단계에서는 Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인한다.
* Concurrent Sweep 단계에서는 쓰레기를 정리하는 작업을 한다. 이 작업도 다른 스레드가 실행되고 있는 상황에서 진행한다.
* Stop-the-world, 멈추는 시간이 짧다.
* 모든 애플리케이션의 응답 속도가 매우 중요할 때 사용한다.
* Low Latency GC라고도 한다.
* 다른 GC 방식보다 메모리와 CPU를 더 많이 사용한다.
* Compaction 단계가 기본적으로 제공되지 않는다. 왼쪽으로 메모리를 몰아 놓는 작업을 수행하지 않는다.
* 2개 이상의 프로세서를 사용하는 서버에 적당하다.
* 조각난 메모리가 많아 Compaction 작업을 실행하면 다른 GC 방식의 Stop the world 시간 보다 더 길기 때문에 Compaction 작업이 얼마나 자주, 오랫동안 수행되는지 확인해야 한다.

#### G1 GC
* 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다.
* 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다.
* 가장 빠르다.
* Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 방식이다.