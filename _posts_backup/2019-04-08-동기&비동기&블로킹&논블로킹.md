
---
layout: post
title: "동기 & 비동기 & 블로킹 & 논블로킹"
description: "동기 & 비동기 & 블로킹 & 논블로킹"
date: 2019-04-08
tags: [동기, 비동기, 블로킹 , 논블로킹]
comments: true
share: true
---

#### 동기(Synchronous, 동시에 일어나는, 같은 시기)
* 동시에 일어난다.
* 요청과 그 결과가 동시에 일어나서 요청을 하면 바로 그 요청한 자리에서 결과가 주어진다.
* 시간이 얼마가 걸리든 상관 안하고 요청한 그 자리에서 결과를 주겠다는 약속 같은 것이다.
* 요청과 결과가 한자리에서 동시에 일어난다.
* 설계가 매우 간단하고 직관적이다.
* 결과가 주어질 때 까지 아무것도 못하고 대기해야 한다.
* System Call이 끝날때까지 기다리고 결과물을 가져온다.

#### 비동기(ASynchronous, 동시에 일어나지 않은, 같은 시기가 아닌)
* 동시에 일어나지 않는다.
* 요청과 결과가 동시에 일어나지 않아 바로 결과가 주어지지 않고 나중에 처리된다.
* 동기 방식보다 설계다 복잡하다.
* 결과가 주어지는 시간이 길어져도 그 시간 동안 다른 작업을 할 수 있으므로 좀 더 효율적으로 자원을 사용할 수 있다.
* System Call이 완료되지 않아도 나중에 완료가 되면 그 때 결과물을 가져온다.
* 주로 CallBack 함수를 통해 결과물을 가져온다.

----

#### Blocking(블로킹)
* 작업이 중단된다는 의미이다.
* 네트워크 통신에서 요청이 발생하고 완료될 때 까지 모든 일을 중단한 상태로 대기해야 하는 것을 의미한다.
* 블로킹 방식의 소켓 통신은 결과가 올 때 까지 다른 작업을 중단하고 하염없이 기다리게 된다.
* 설계가 간단하다.
* System Call이 끝날때까지 프로그램은 대기해야 하고 System Call이 완료가 되면 그때야 Return한다.
* Wait Queue에 들어간다.
* Scanner 입력

#### Non-Blocking(논블로킹)
* 작업이 중단되지 않는다.
* 통신이 완료 될 때까지 중단되는 블로킹의 반대 개념이다.
* 통신이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있으므로 경우에 따라 효율이나 반응속도가 더 뛰어나다.
* 설계는 블로킹에 비해 복잡해 진다.
* System Call이 완료되지 않아도 대기하지 않고 Return 해 버린다.
* Wait Queue에 들어가지 않는다.

----

#### 동기 & 비동기 차이점
* 결과물을 가져오는 시점이 다르다.

#### 블로킹 & 논블로킹 차이점
* 프로그램이 바로 실행할 수 있는 유무가 다르다.

#### 동기 & 블로킹 차이점
* Wait Queue 유무
* 동기는 System Call의 Return을 기다리는 동안 Wait Queue에 머물 수도 아닐 수도 있다.
* 블로킹은 System Call의 Return을 기다리는 동안 필수로 Wait Queue에 머문다.

#### 비동기 & 논블로킹 차이점
* System Call이 즉시 반환될 때 데이터의 포함 유무
* 비동기는 요청에 처리 완료와 관계 없이 응답한다. 이후 운영체제에서 응답할 준비가 되면 응답한다.
* 논블로킹은 요청에 처리할 수 있으면 바로 응답하고 아니면 Error를 반환한다.

#### 동기/비동기 & 블로킹/논블로킹
* 동기/비동기는 함수를 호출하는 쪽(메인 스레드)
* 블로킹/논블로킹은 함수 쪽(작업 스레드)

----

#### 동기 + 블로킹
* System Call이 끝날때까지 기다리고 결과물을 가져온다.
* System Call이 끝날때까지 프로그램은 대기해야 하고 System Call이 완료가 되면 그때야 Return한다.
* 메인스레드는 함수를 호출하고, 반환값을 얻을 때 까지 대기해야 한다.
* 함수를 수행하는 스레드는 작업이 끝날때 까지 대기하고, 반환값을 계산해서 넘겨야 한다.
* Read/Write

#### 동기 + 논블로킹
* System Call이 끝날때까지 기다리고 결과물을 가져온다.
* System Call이 완료되지 않아도 대기하지 않고 Return 해 버린다.
* 메인스레드는 함수를 호출하고, 반환값을 얻을 때 까지 대기해야 한다.
* 함수를 수행하는 스레드는 작업 종료 여부와 관계없이 반환값을 넘긴다.
* 메인스레드는 함수로 부터 받은 반환값이 정상일 때 까지 계속 함수를 실행한다.
* Read/Write(O_NONBLOCK)
* 정상 데이터가 올 때 까지 계속 System Call을 한다.

#### 비동기 + 블로킹
* System Call이 완료되지 않아도 나중에 완료가 되면 그 때 결과물을 가져온다.
* System Call이 끝날때까지 프로그램은 대기해야 하고 System Call이 완료가 되면 그때야 Return한다.
* I/O multiplexing(Select/Poll)

#### 비동기 + 논블로킹
* System Call이 완료되지 않아도 나중에 완료가 되면 그 때 결과물을 가져온다.
* System Call이 완료되지 않아도 대기하지 않고 Return 해 버린다.
* AIO
* I/O 응답이 도착하면 신호나 콜백으로 I/O 전달을 완료한다.
* node.js