---
layout: post
title:  "Spring 01"
date:   2020-01-16 10:48:00
author: bghgu
categories: Spring
tags: [Spring]
---

#### Framework와 IoC(Inversion of Control)
* Framework는 IoC(Inversion of Control)을 포함해야한다.
* IoC라는 개념을 포함하느냐 안하느냐가 Framework와 Library에 차이점일 것이다.
* 프레임워크의 사전적인 의미는 틀, 뼈대 라는 뜻이다.
* IoC는 제어의 역전 으로 해석할 수 있다.

#### IoC가 의미하는 것
* 객체(Bean) 생명주기 관리(컨트롤)
* DI 패턴 제공
* 비즈니스 로직에 집중

#### 프레임워크의 장점과 단점
* 장점
    * 빠른 개발
    * IoC, DI
    * 비즈니스 로직에 집중
* 단점
    * 프레임워크에 의존
    * 프레임워가 제공하는 규칙이나 틀에 맞춰 개발
    * 프레임워크를 이해해야 한다.

#### Bean 빈(빈 오브젝트)
* IoC 컨테이너에 저장된 객체
* 스프링이 IoC 방식으로 관리하는 오브젝트
* 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.

#### AnnotationConfigApplicationContext
* 어노테이션 기반 설정을 토대로 애플리케이션을 관리하기 위한 ApplicationContext에 구현체 중 하나이다.

#### getBean
* 빈으로 등록된 오브젝트를 가져오기(생성이 아닌 가져온다고 표현한다. IoC 컨테이너에 등록된 빈을 가져오기 때문이다.) 위해 사용하는 메소드이다.
* 첫번째 인자 값인 String type은 bean의 이름이다.
* 이 값은 @Bean의 name 속성을 의미한다.

#### IoC Container
* 스프링 프레임워크에서 생성된 빈을 관리하는 공간이 존재한다.
* 그 공간은 여러가지 용어로 사용되는데 스프링 컨테이너, DI 컨테이너, IoC 컨테이너, 빈 컨테이너 등으로 사용된다.
* 컨테이너에서 하는 역할
    * 빈(객체) 보관
    * 빈 생명주기(생성, 사용, 소멸) 관리
    * DI
* IoC 컨테이너는 물리적인 공간은 아니다.
* 스프링 프레임워크에서 논리적으로 구현되어 있는 공간인데 이 의미는 메모리에 상주되어 관리된다는 뜻이다.
* 그렇기 때문에 IoC 컨테이너 역시 JVM 안에서 생성되고 관리는 되는 영역이지만 일반 객체와 빈은 어떤 영역에 생성되어 관리 되는지에 따라 구분될 수 있다.
* IoC 컨테이너는 DI를 지원한다고 했는데, DI를 하기 위해서는 의존되는 객체와 사용되는 개체 모두 Bean 이어야 가능하다.
* 즉 사용, 의존 객체 모두 IoC 컨테이너에서 관리되어야 한다는 뜻이다.
* 같은 타입에 빈은 List로 DI가 가능하다.
* 빈 대싱이 되는 객체는 반드시 기본 생성자가 필요하다.
* 생성자와 setter 메소드를 통해 DI가 가능하다.

#### 꼭 인터페이스를 생성해야 할까?
* 스프링 DI 예제 같은 경우와 같이 알림하는 방법이 여러가지인 경우에 인터페이스 사용은 적절하다.
* 하지만 스프링 프레임워크로 작성된 몇몇 코드를 살펴보면 클래스는 모두 인터페이스를 구현했다.
* 즉 1:1로 인터페이스를 구현하는 경우가 있는데 
1. 주입을 통핸 테스트 코드를 작성하는 경우
2. 여러가지 구현체가 존재하는 경우, 또는 미래에 여러가지 구현체가 생길 수 있는 가능성이 큰 경우
3. 프레임워크를 제공하는 경우

#### 왜 생성자 또는 메소드를 통한 DI를 해야 할까?
* ㄴㅇ

#### Bean을 등록하는 방법
* 스프링에서 설정하는 방법은 여러가지 방법이 있다.
* 대부분 스프링 부트라는 프로젝트를 사용하는데 설정 방법이 굉장히 쉽다.
* xml로 설정하는 방법이 가장 원초적인 방법이고 그 후에 javaConfig 설정이 나왔다.
* @Bean
* @ComponentScan
    * ComponentScan 어노테이션에 basePackages는 package 경로를 선언하면 그 경로 밑에 @Component가 붙은 클래스를 모두 Scan해 Bean으로 동록한다.
    * 자바에서 어노테이션은 또 다른 어노테이션을 붙여 사용할 수 있는데 Component가 붙은 어노테이션은 모두 ComponentScan 대상에 해당한다.
    * 이에 해당하는 대표적인 어노테이션이 @Service, @Repository, @Controller가 있다.
    * ComponentScan 어노테이션 또한 설정 어노테이션이기 때문에 Configuration 어노테이션과 함께 사용해야 한다.
* @Autowired
    * 의존 관계를 자동으로 설정할 때 사용하며, 생성자, 필드, 메소드의 세 곳에 적용할 수 있다.
    * 이 어노테이션을 사용하면 스프링이 알아서 설정된 메소드의 타입에 맞는 빈 객체를 알맞게 연결해준다.
* @Qualifier
    * @Autowired 어노테이션을 사용할 경우 적용 대상이 빈은 하나여야 한다.
    * 하지만, 동일한 타입의 빈 객체를 두개 이상 정의 했을 때 사용할 수 있다.
* @Resource
    * @Autowired와 동일하게 빈 객체를 연결해 주지만, 이름을 기준으로 빈 객체를 찾는 다는 점이 다르다.
* @Inject
    * @Autowired와 동일한 기능을 수행한다.
    * 다른 점은 JSR-330 표준 어노테이션이라는 점이다.
    * 특정 프레임워크에 종속되지 않는 애플리케이션을 구성할 경우에 사용하면 좋을 것이다.
* @Named
    * @Inject와 같이 JSR-330 표준에 포함되어 있다.
    * @Qualifier와 동일한 기능을 하고 있으며, 사용할 빈의 이름을 지정해야 한다는 점이 다르다.

#### DI Framework
* 스프링 프레임워크에서 IoC와 DI가 가능하게 하는 모듈은 Spring-context 모듈이다.

#### 참고
* https://www.slipp.net/wiki/pages/viewpage.action?pageId=25527606