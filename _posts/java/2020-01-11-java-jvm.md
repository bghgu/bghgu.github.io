---
layout: post
title:  "Java Virtual Machine"
date:   2020-01-11 20:02:00
author: bghgu
categories: JAVA
tags: [JAVA]
---

#### JVM(Java Virtual Machine) 자바 가상 머신
* 자바 가상 머신
* 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다.
* JVM은 자바와 운영체제 사이에서 중개자 역할을 수행하여 자바가 운영체제에 구애받지 않고 재사용을 가능하게 해준다.
* 메모리 관리, GC를 수행한다.
* 스택 기반의 가상 머신으로 대다수의 명령어가 스택 선두에서 피 연산자를 택하고 다시 스택에 넣는다.
* 자바 바이트 코드를 실행할 수 있는 주체이다.
* 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
* JVM은 플랫폼에 독립적이다.
* 이론적으로 모든 자바 프로그램은 CPU가 운영체제의 종류에 무관하게 동작할 것을 보장한다.
* 포인터를 지원하지만 C처럼 주소 값을 임의로 조작이 가능한 포인터 연산을 지원하지 않는다.
* GC를 이용해 메모리(자원)을 관리한다.
* Class Loader, Runtime Data Area, Execution Engine로 구성되어 있다.

#### JVM 실행 과정
1. 자바 애플리케이션이 실행되면 JVM은 운영체제로부터 이 프로그램이 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. Javac 컴파일러가 자바 소스코드(.java)를 읽어 들여 자바 바이트 코드(.class)로 변환시킨다.
3. 클래스 로더를 통해 클래스 파일들을 JVM으로 적재(Loading)한다.
4. 적재된 클래스 파일들은 Execution Engine을 통해 해석된다.
5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 된다.
6. 이러한 실행 과정 속에서 JVM은 필요에 따라 Thread Synchronization과 같은 GC 관리 작업을 수행한다.

#### Class Loader
* 런타임(Runtime) 시점에 동적으로 클래스를 적재(Loading)하게 해준다.
* 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리(Runtime Data Area)에 로드하게 된다.
* .jar 파일 내 저장된 클래스들을 JVM 위에 탑재하고, 사용하지 않는 클래스들을 메모리에서 삭제한다.
* 자바는 동적 코드이다. 컴파일(Compile) 타임이 아니라 런타임 시점에 참조한다. 즉, 클래스를 처음으로 참조할 때 해당 클래스를 적재하고 링크한다.

#### 클래스 로딩을 위한 JVM의 로딩 절차
* 메소드 영역에 바이트 코드가 올라가는 것을 클래스 로딩이라고 한다.
* 클래스 로딩이 이루어지는 이유 : 어떤 메소드가 호출되려면 먼저 그 메소드를 갖고 있는 클래스 파일이 메모리에 로딩되어 있어야 한다.
* 그래서 클래스를 실행할 때 .class 파일을 찾아서 메모리에 로딩하는 것이다.
1. 어떤 메소드를 호출하는 문장을 만났는데, 그 메소드를 가진 클래스 바이트 코드가 아직 로딩된 적이 없다면, 곧바로 JVM은 JRE 라이브러리 폴더에서 클래스를 찾는다.
2. 없으면 CLASSPATH 환경 변수에 지정된 폴더에서 클래스를 찾는다.
3. 찾았으면 그 클래스 파일이 올바른지 바이트 코드를 검증한다.
4. 올바른 바이트 코드라면 메소드 영역으로 파일을 로딩한다.
5. 클래스 변수를 만들라는 명령어가 있으면 메소드 영역에 그 변수를 준비한다.
6. 클래스 블록이 있으면 순서대로 그 블록을 실행한다.
7. 이렇게 한 번 클래스의 바이트 코드가 로딩되면 JVM이 종료될 때까지 유지된다.

#### Loader
* 목적 프로그램(기계어 파일)을 실행 가능한 파일로 변환하기 위해 컴퓨터의 주 기억 장치를 할당(Allocation)하거나, 여러 개의 목적 프로그램을 연계 편집하여 CPU가 처리할 수 있는 프로그램으로 변환시킨다.
* 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 주 기억 장치에 올려 놓는 작업을 수행한다.
* 목적 프로그램들끼리 연결(Linking)시키거나, 재배치(Relocation)하는 등 포괄적인 작업을 수행한다.
* 할당(Allocation) -> 연결(Linking) -> 재배치(Relocation) -> 적재(Loading) 순으로 진행된다.

#### Runtime Data Areas
* 자바 애플리케이션을 수행하기 위해 운영체제로부터 할당 받은 메모리 공간이다.

#### PC Register
* 현재 수행중인 JVM 명령어의 주소를 가진다.
* 스레드가 어떤 명령어를 실행되어야 할 지에 대한 기록을 하는 부분이다.
* 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.

#### JVM Stack
* 프로그램 실행 과정에서 임시로 할당되었다가 메소드를 빠져나가ㅕㄴ 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
* 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장한다.
* 지역 변수와 매개 변수가 저장된다.
* 지역 변수 = 로컬 변수, 매개 변수 = 파라미터
* 변수가 선언된 그 블록 안에서만 유효한 변수들이다.
* 참조 변수에 저장되는 메모리 주소는 스택 영역에 저장되지만, 그 주소가 가리키는 메모리는 모두 힙 영역에 저장된다.
* 메소드 호출 시 각각의 스택 프레임(해당 메소드만을 위한 공간)이 생성된다.
* 메소드 수행이 끝나면 프레임별로 삭제를 진행한다.
* 재귀함수보다는 반복문이 더 빠른 이유이다.
* 메소드 안에서 사용되는 지역 변수(Local Variable)을 저장한다.
* 호출된 메소드의 매개 변수, 지역 변수, 리턴 값 및 연산 시 일어나느 값들을 임시로 저장한다.
* 각 스레드마다 하나씩 생성된다.
* JVM은 오직 하나의 스택 프레임을 추가하고 제거하는 동작만 수행한다. (stack - PUSH & POP)
* 예외 발생 시 printStackTrace() 등의 메소드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.

#### Native Method Stack
* 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행 시키는 영역이다.
* 자바가 아닌 다른 언어로 작성된 코드를 위한 영역이다.
* Java Native Interface(JNI)를 통해 바이트 코드로 전환하여 저장하게 된다.
* 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다.
* 이 부분을 통해 C코드를 실행시켜 커널에 접근할 수 있다.
* 각 스레드마다 하나씩 생성된다.
* JNI을 이용하여 JVM 내부에 영향을 주기 않게 하기 위해 Native Method Stack에 새로운 스택 프레임을 생성하여 추가한다.

#### Method Area, Class Area, Static Area
* 클래스와 인터페이스에 대한 Runtime Constant Pool, 필드와 메소드 코드, Static 변수, final class 정보, 메소드와 바이트 코드 등이 저장된다.
* 모든 스레드가 공유하는 영역이다.
* JVM이 시작될 때 생성된다.
* main 메소드는 static이기 때문에 바로 실행할 수 있다.
* 자바 프로그램은 main 메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어간다.
* Field Information : 멤버 변수의 이름, 데이터 타입, 접근 제어 지시자에 대한 정보
* Method Infromation : 메소드의 이름, 리턴 타입, 매개 변수, 접근 제어 지시자에 대한 정보
* Type Information : 클래스인지 인터페이스인지 여부, 타입의 속성, 전체 이름, 슈퍼 클래스의 전체 이름
* 이 공간에 Runtime Constant Pool 이라는 별도의 관리 영역도 함께 존재한다.

#### Runtime Constant Pool
* 각 클래스와 인터페이스의 상수, 메소드와 필드에 대한 모든 참조를 담고 있는 테이블이다.
* 메소드나 필드의 실제 메모리 상 주소를 찾을 땐 해당 Pool을 참고한다.

#### Heap Area
* 객체를 저장하는 가상 메모리 공간이다.
* new 연산자로 생성된 객체와 배열을 저장한다.
* class area 영역에 올라온 클래스들만 객체로 생성할 수 있다.
* 프로그램 상에서 런타임시 동적으로 할당하여 사용하는 영역이다.
* 모든 스레드가 공유해서 사용한다.
* GC의 대상이다.
* 인스턴스를 별도의 힙 영역에 할당하는 이유는 인스턴스의 소멸 방법과 소멸 시점이 지역변수(스택 영역 할당)와는 다르기 때문이다.
* 참조 변수들은 실행될 때마다 많은 데이터들을 스택 메모리에 저장했다가 해제하는 것이 매우 비효율적이므로, 힙 영역에 실제 객체가 저장되고, 스택 메모리에는 간단하게 그 주소만 저장된다.

#### Execution Engine
* 클래스를 실행시키는 역할이다.
* 클래스 로더가 JVM내의 Runtime Data Area에 바이트 코드를 배치시키고, 이것은 실행 엔진에 의해 실행된다.
* 자바 바이트 코드는 기계가 바로 수행할 수 있는 언어보다 비교적 인간이 보기 편한 형태로 기술된 것이다.
* 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계로 실행할 수 있는 형태로 변경한다.
* 인터프리터 방식과 JIT 컴파일러 방식이 있다.

#### Interpreter 인터프리터
* 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
* 한줄 씩 수행하기 때문에 느리다.

#### JIT(Just In Time) Compiler
* 인터프리터 방식의 단점을 보완하기 위해 도입된 컴파일러이다.
* 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다.
* 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행된다.
* JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것보다 훨씬 오래 걸리므로 한번만 실행되는 코드라면 컴파일하지 않고 인터프리팅 하는 것이 유리하다.
* JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넘을 때에만 컴파일을 수행한다.

#### 참고
* 