---
layout: post
title:  "TCP"
date:   2020-01-17 16:31:00
author: bghgu
categories: NETWORK
tags: [NETWORK]
---

#### TCP (Transmission Control Protocol) 전송 제어 프로토콜
* 연결 지향형 프로토콜이다.
* 데이터의 경계가 없다.
* 전화(받았는지 못 받았는지 확인할 수 있다.)
* UDP에 비해 전송 속도가 느리다.
* 서버 소켓과 클라이언트 소켓의 구분이 있다.
* 전송 순서대로 데이터가 송신되고 수신된다.
* 중간에 데이터가 소멸하지 않는다.
* 1대1 연결 구조이다.
* 데이터를 주고받을 양단간에 먼저 연결을 설정하고 설정된 연결을 통해 양방향으로 데이터를 전송한다.
* 메시지 수신을 확인한다.
* 메시지가 보내진 순서를 보장하기 위해 재조립한다.
* 안정성이 있어야 하는 애플리케이션에서 사용한다.

#### 3 Way HandShake
* TCP 통신을 시작하기 위한 연결방식이다.
* 최초에 서버에서 열려있는 포트는 LISTEN, 클라이언트에서는 CLOSED 상태다.
1. 클라이언트에서 서버에 연결 요청을 하기 위해 연결하고자 하는 서버의 포트로 SYN을 보낸다.
2. 서버에서 해당 포트는 LISTEN 상태에서 SYN을 받고 SYN_RCV 상태가 된다.
3. 클라이언트에게 요청을 정상적으로 받았다는 대답(ACK)과 클라이언트에게 포트를 열어달라는 SYN을 보낸다.
4. 클라이언트에서는 SYN + ACK를 받고 ESTABLISHED로 상태를 변경하고 서버에 요청을 잘 받았다는 ACK를 전송한다.
5. ACK를 받은 서버는 상태가 ESTABLISHED로 변경된다.

#### 4 Way HandShake
* TCP 통신을 종료하기 위한 방식이다.

#### 정상적인 종료 상황
* 최초에 서로 통신 상태이기 때문에 서버, 클라이언트 모두 ESTABLISHED 상태이다.
1. 통신을 종료하고자 하는 클라이언트가 서버에게 FIN을 보내고, 자신은 FIN_WAIT_1로 대기한다.
2. FIN을 받은 서버는 해당 포트를 CLOSE_WAIT로 바꾸고 잘 받았다는 ACK를 클라이언트에게 보낸다. 그와 동시에 서버에서 해당 포트에 연결되어있는 애플리케이션에 Close()를 요청한다.
3. ACK를 받은 클라이언트는 FIN_WAIT_2 상태로 변경한다.
4. Close() 요청을 받은 애플리케이션은 종료 프로세스를 진행해 최종적으로 close()가 되고 서버는 FIN을 클라이언트에게 전송 후 자신은 LAST_ACK 상태가 된다.
5. FIN_WAIT_2에서 서버가 연결을 종료했다는 신호를 기다리다가 FIN을 받으면 잘 받았다고 ACK를 서버에게 전송한다. 클라이언트드는 TIME_WAIT로 상태를 바꾼다. TIME_WAIT 상태는 일정 시간이 지나면 CLOSED로 변경된다. 최종 ACK를 받은 서버는 자신의 포트도 CLOSED로 닫게 된다.

#### 비 정상적인 종료 상황
* CLOSE_WAIT : 애플리케이션에서 Close()를 처리하지 못하면 서버 포트는 CLOSE_WAIT 상태로 계속 기다리게 된다. CLOSE_WAIT 상태가 statement에 많아지게 되면, Hang이 걸려 더는 연결을 하지 못하게 된다.
* FIN_WAIT_1 : 서버에 종료 요청을 했는데 ACK를 받지 못한 상태로 기다리고 있다. 서버를 찾을 수 없거나, 네트워크 방화벽의 문제일 수 있다. 일정 시간이 지나 TIME OUT이 되면 자동으로 닫힌다.
* FIN_WAIT_2 : 클라이언트가 서버에 종료를 요청한 후 서버에서 요청을 접수했다고 ACK를 받았지만, 서버에서 종료했다는 FIN 상태를 받지 못하고 기다리고 있는 상태다. 양방의 두 번의 통신이 이미 이루어졌기 때문에 네트워크 문제는 아니라고 판단한다. 서버에서 CLOSED를 처리하지 못하는 경우일 수도 있다. 일정 시간이 지나 TIME OUT이 되면 스스로 CLOSE 하게 된다.
* TIME OUT이 길어져서 많은 수의 소켓이 늘어만 난다면 메모리 부족 현상이 발생할 수 있다.