---
layout: post
title:  "HTTP"
date:   2020-01-15 15:42:00
author: bghgu
categories: WEB
tags: [WEB]
---

#### HTTP
* HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다.
* HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 한다.
* 클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.
* 하나의 완전한 문서는 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등 불러온(fetched) 하위 문서들로 재구성된다.
* 클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다.
* 보통 브라우저인 클라이언트에 의해 전송되는 메시지를 요청(Requests)이라고 부르며, 그에 대한 서버에서 응답으로 전송되는 메시지를 응답(Responses)이라고 부른다.
* 1990년대 초에 설계된 HTTP는 거듭하여 진화해온 확장 가능한 프로토콜이다.
* HTTP는 애플리케이션 계층의 프로토콜로, 신뢰 가능한 전송 프로토콜이라면 이론상으로 무엇이는 사용할 수 있으나 TCP 혹은 암호화된 TCP 연결인 TLS를 통해 전송된다.
* HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라 이미지와 비디오 혹은 HTML 폼 결과와 같은 내용을 서버로 포스트(POST)하기 위해서도 사용된다.
* HTTP는 또한 필요할 때마다 웹 페이지를 갱신하기 위해 문서의 일부를 가져오는데 사용될 수도 있다.

#### HTTP 기반 시스템의 구성요소
* HTTP는 클라이언트-서버 프로토콜이다.
* 요청은 하나의 개체, 사용자 에이전트(또는 그것을 대신하는 프록시)에 의해 전송된다.
* 대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있다.
* 예를 들어, 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우이다.
* 각각의 개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 response라고 불리는 응답을 제공한다.
* 이 요청과 응답 사이에는 여러 개체들이 있는데, 예를 들면 다양한 작업을 수행하고 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.
* 실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재한다. 라우터, 모뎀 등
* 웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨진다.
* HTTP는 애플리케이션 계층의 최상위에 있다.
* 네트워크 문제를 진단하는 것도 중요하지만, 기본 레이어들은 HTTP의 명세와는 거의 관련이 없다.

#### 클라이언트 : 사용자 에이전트
* 사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구이다.
* 이 역할은 주로 브라우저에 의해 수행된다.
* 브라우저는 항상 요청을 보내는 개체이다.
* 웹 페이지를 표시하기 위해, 브라우저는 페이지의 HTML 문서를 가져오기 위한 요청을 전송한 뒤, 파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하우 리소스들(보통 이미지와 비디오)을 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져온다.
* 그런 뒤에 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 그런 리소스들을 혼합한다.
* 브라우저에 의해 실행된 스크립트는 이후 단계에서 좀 더 많은 리소스들을 가져올 수 있으며 브라우저는 그에 따라 웹 페이지를 갱신하게 된다.
* 웹 페이지는 하이퍼텍스트 문서로, 표시된 텍스트의 일부는 사용자가 사용자 에이전트를 제어하고 웹을 돌아다닐 수 있도록 새로운 웹 페이지를 가져오기 위해 실행될 수 있는 링크임을 뜻한다.
* 브라우저는 HTTP 요청 내에서 이런 지시 사항들을 변환하고 HTTP 응답을 해석하여 사용자에게 명확한 응답을 표시한다.

#### 웹 서버
* 통신 채널의 반대편에는 클라이언트에 의한 요청에 대한 문서를 제공하는 서버가 존재한다.
* 서버는 사실 상 논리적으로 단일 기계이다.
* 이는 로드 밸런싱 혹은 그때 그때 다른 컴퓨터(캐시, DB, 서버 등과 같은)들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합일 수도 있기 때문이다.
* 서버는 반드시 단일 머신일 필요는 없지만, 여러 개의 서버를 동일한 머신 위에서 호스팅 할 수는 있다.

#### 프록시
* 웹 브라우저와 서버 사이에서는 수많은 컴퓨터와 머신이 HTTP 메시지를 이어 받고 전달한다.
* 여러 계층으로 이루어진 웹 스택 구조에서 이러한 컴퓨터/머신들은 대부분은 전송, 네트워크 혹은 물리 계층에서 동작하며, 성능에 상당히 큰 영향을 주지만 HTTP 계층에서는 이들이 어떻게 동작하는지 눈에 보이지 않는다.
* 이러한 컴퓨터/머신 중에서도 애플리케이션 계층에서 동작하는 것들을 일반적으로 프록시라고 부른다.
* 프록시는 눈에 보이거나 그렇지 않을 수도 있으며(프록시를 통해 요청이 변경되거나 변경되지 않는 경우를 말함) 다양한 기능들을 수행할 수 있다.
* 캐싱(캐시는 공개 또는 비공개가 될 수 있다.(예: 브라우저 캐시))
* 필터링(바이러스 백신 스캔, 유해 컨텐츠 차단(자녀 보호)기능)
* 로드 밸런싱(여러 서버들이 서로 다른 요청을 처리하도록 허용)
* 인증(다양한 리소스에 대한 접근 제어)
* 로깅(이력 정보를 저장)

#### HTTP는 간단하다.
* HTTP는 사람이 읽을 수 있으며 간단하게 고안되었다.
* 심지어 HTTP/2가 다소 더 복잡해졌지만 여전히 HTTP 메시지를 프레임별로 캡슐화하여 간결함을 유지하였다.
* HTTP 메시지들은 사람이 읽고 이해할 수 있어, 테스트하기 쉽고 초심자의 진입장벽을 낮췄다.

#### HTTP는 확장 가능하다.
* HTTP/1.0에서 소개된, HTTP 헤더는 HTTP를 확장하고 실험하기 쉽게 만들어주었다.
* 클라이언트와 서버가 새로운 헤더의 시맨틱에 대해 간단한 합의만 한다면, 언제든지 새로운 기능을 추가할 수 있다.

#### HTTP는 상태가 없지만, 세션은 있다.
* HTTP는 상태를 저장하지 않는다.(Stateless)
* 동일한 연결 상에서 연속하여 전달된 두 개의 요청 사이에는 연결고리가 없다.
* 이는 e-커머스 쇼핑 바구니처럼, 일관된 방식으로 사용자가 페이지와 상호 작용하길 원할 때 문제가 된다.
* 하지만, HTTP의 핵심은 상태가 없는 것이지만 HTTP 쿠기는 상태가 있는 세션을 만들도록 해준다.
* 헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

#### HTTP와 연결
* 연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖이다.
* HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않는다.
* 다만 그저 신뢰할 수 있거나 메시지 손실이 없는(최소한의 오류는 표시) 연결을 요구할 뿐이다.
* 인터넷 상의 가장 일반적인 두 개의 전송 프로토콜 중에서 TCP는 신뢰할 수 있으며 UDP는 그렇지 않다.
* 그러므로 HTTP는 연결이 필수는 아니지만 연결 기반인 TCP 표준에 의존한다.
* 클라이언트와 서버가 HTTP를 요청/응답으로 교환하기 전에 여러 왕복이 필요한 프로세스인 TCP 연결을 설정해야 한다.
* HTTP/1.0의 기본 동작은 각 요청/응답에 대해 별도의 TCP 연결을 여는 것이다.
* 이 동작은 여러 요청을 연속해서 보내는 경우에는 단일 TCP 연결을 공유하는 것보다 효율적이지 못한다.
* 이러한 결함을 개선하기 위해, HTTP/1.1은 파이프라이닝 개념과 지속적인 연결의 개념을 도입했다.
* 기본적인 TCP 연결은 Connection 헤더를 사용해 부분적으로 제어할 수 있다.
* HTTP/2 연결을 좀 더 지속되고 효율적으로 유지하는데 도움이 되도록, 단일 연결 상에서 메시지를 다중 전송(multiplex)하여 한 걸음 더 나아갔다.

#### 참고
* https://developer.mozilla.org/ko/docs/Web/HTTP/Overview