---
layout: post
title:  "DB Index"
date:   2020-01-12 20:49:00
author: bghgu
categories: Database
tags: [Database]
---

#### Index 인덱스
* RDBMS에서 검색 속도를 높이기 위해 사용하는 기술이다.
* 색인(컬럼과 인덱스 주소를 따로 파일로 저장한다.)
* 해당 테이블의 컬럼을 색인화하여 검색 시 테이블 전체를 Full Scan 하는 것이 아니라 색인화 되어있는 인덱스 파일을 검색하여 검색 속도를 빠르게 한다.
* 인덱스는 키 컬럼 순으로 정렬되어 있기 때문에 특정 값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다. (Range Scan)
* B- 트리로 저장된다.
* B- 트리를 사용하는 이유는 일관된 검색 속도를 유지하기 위해서이다.
* B- 트리는 균형 트리이기 때문에 일정하고 빠른 속도를 유지할 수 있다.
* 인덱스로 설정한 컬럼 값이 변경되거나 추가되면 인덱스 역시 변경된다. 따라서 적절하게 인덱스를 설정해야 한다.
* 데이터의 삽입, 삭제가 빈번한 경우 인덱스의 성능이 떨어진다. 매번 트리를 수정해야 하기 때문이다.
* 인덱스가 데이터베이스의 공간을 차지하기 때문에 추가적인 공간이 필요하다. (10%)
* 인덱스를 생성하는 데 시간이 많이 소요될 수 있다.
* select의 where/join 시에만 인덱스가 사용되며, select의 검색 속도를 빠르게 하는 것이 목적이다.
* where의 타겟이 되는 컬럼을 인덱스로 만드는 것이 좋다.
* 데이터의 중복도가 높은 컬럼은 인덱스로 만들어도 효과가 없다.
* 외래키가 사용되는 컬럼은 인덱스를 생성해 주는 것이 좋다.
* 사용하지 않는 인덱스는 제거하는 것이 좋다.
* join시 다른 테이블의 열을 추출하기 위해 사용한다.
* 단일 인덱스 여러개보다는 다중 컬럼 인덱스의 생성을 고려한다.
* 되도록 동등 비교가 좋다.
* 가장 효율적인 자료형은 정수형이다.
* 인덱스는 MYI(MySQL Index) 파일에 저장 된다.
* 조건과 일치하는 열을 빨리 찾기 위해 사용한다.
* Join시 다른 테이블의 열을 추출하기 위해 사용한다.
* MAX, MIN 값을 찾기 위해 사용한다.
* 인덱스의 키의 크기는 되도록 작게 설계해야 성능에 유리하다.
* 분포도가 좋은 컬럼(좁은 범위), 기본키, 조인의 연결고리가 되는 컬럼을 인덱스로 구성한다.
* 단일 인덱스 여러개보다 다중 컬럼 인덱스의 생성을 고려한다.
* 수정이 빈번하지 않은 컬럼으로 인덱스를 구성하는게 좋다.
* 조인 시 자주 사용하는 컬럼은 인덱스 추가를 고려한다.
* 인덱스를 많이 생성하면 삽입, 수정, 삭제의 성능 저하의 원인이 될 수 있다.
* Index Scan이 테이블 순차 Scan 보다 항상 빠르지는 않다. 보통 선택도가 5 ~ 10% 이내인 경우 Index Scan이 우수하다.

#### 조합 인덱스
* 조합 인덱스가 단일 인덱스보다 많은 장점이 있지만 2개의 단일 인덱스 사용이 성능상 더 좋다.
* 선택도가 좋지 않은 두 개 이상의 컬럼을 조합하여 선택도가 좋은 조합 인덱스가 된다.
* 질의 컬럼이 모두 조합 인덱스에 있는 경우, 물리적인 데이터 블록을 읽을 필요가 없다.
* AND 연산자에 의해 자주 같이 질의되는 컬럼들, 다수의 여러 개의 질의가 특정 컬럼들을 질의
* 자주 사용되는 컬럼들을 왼쪽에, 동일한 사용 빈도이면 선택도가 좋은 것을 왼쪽에 배치하는 것이 좋다.
* 가능하다면 유니크 인덱스를 사용한다.
* 정렬 작업을 최소화한다.
* 앞에서 부터 키를 탄다. (키1 검사 후 키2 검사)
* MySQL에서는 하나의 인덱스에 최대 15개의 컬럼으로 구성될 수 있다.

#### 인덱스 사용
* 인덱스를 사용한 필드의 조건 검색이 not, <, >일 경우 인덱스를 사용하지 않는다.
* =>, <=, =, Between은 사용이 가능하다.
* 인덱스를 사용한 필드의 조건 검색이 like "%값", "%값%", 인 경우 인덱스를 사용하지 않는다.
* like "값%"는 사용이 가능하다.
* 인덱스를 사용한 필드의 조건 검색이 다른 필드와 비교일 경우 인덱스를 사용하지 않는다. (where 컬럼1 = 컬럼2)
* 인덱스는 order by, group by에도 영향을 끼친다. 다음과 같은 경우는 index를 타지 않는다.
    * order by 인덱스 컬럼1, 컬럼2 : 복수의 키에 대해서 order by를 사용한 경우
    * where 컬럼1='값' order by 인덱스 컬럼 : 연속하지 않은 컬럼에 대해 order by를 실행한 경우
    * order by 인덱스 컬럼1 desc, 인덱스 컬럼2 asc : desc, asc를 혼합하여 사용한 경우
    * group by 컬럼1 order by 컬럼2 : group by와 order by의 컬럼이 다른 경우
    * order by asc(컬럼) : order by절에 다른 표현을 사용할 경우
* order by 동작
1. where 절에 일치하지 않은 열을 제외하고 키순서에 따라 모든 열을 읽어 들인다.
2. 각각의 열에 대해 버퍼에 정렬을 위한 키와 열에 대한 포인터의 쌍을 저장한다. 이때 사용되는 버퍼의 크기는 sort_buffer_size에 의해 결정된다.
3. 버퍼가 가득 차면, 퀵소드틑 수행하고 그 결과를 임시 파일에 보관한 뒤 다시 반복한다. sort_buffer_size의 크기에 다 담길 양이면 임시 파일을 만들지 않는다.
4. 다른 임시 파일에 대해 최대 MERGEBUFF(기본값 7)의 영역을 하나의 블록이 될 때까지 다중 병합 작업을 수행한다. 첫 번째 파일의 모든 블록이 두 번째 파일과 같아질 따 까지 반복한다.
5. MERGEBUFF2(기본값 15)보다 작은 수의 블록이 남을 때까지 반복한다.
* order by에 대한 인덱스를 사용하지 못할 경우는 sort_buffer_size와 read_rnd_buffer_size의 크기를 증가시킨다.

#### 참고
* https://code-factory.tistory.com/24 