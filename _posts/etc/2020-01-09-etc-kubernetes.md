---
layout: post
title:  ""
date:   2020-01-09 23:32:00
author: bghgu
categories: ETC
tags: [ETC, Kubernetes]
---

#### Kubernetes 쿠버네티스
* 쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성 있고, 확장가능한 오픈소스 플랫폼이다.
* 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다.
* 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다.
* 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.
* 구글이 2014년 쿠버네티스 프로젝트를 오픈소스화했다.
* 쿠버네티스는 구글의 15여년에 걸친 대규모 상용 워크로드 운영 경험을 기반으로 만들어졌으며 커뮤니티의 최고의 아이디어와 적용 사례가 결합되었다.

#### 여정 돌아보기
* 전통적인 배포 시대
* 가상화된 배포 시대
* 컨테이너 개발 시대
    * 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다.
    * 그러므로 컨테이너는 가볍다고 여겨진다.
    * VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU, 메모리, 프로세스 공간 등이 있다.
    * 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.
    * 컨테이너는 다음과 같은 추가적인 혜택을 제공하기 때문에 인기가 있다.
        * 기민한 애플리케이션 생성과 배포 : VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적이다.
        * 지속적인 개발, 통합 및 배포 : 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고(이미지의 불변성 덕에) 빠르고 쉽게 롤백할 수 있다.
        * 개발과 운영의 관심사 분리 : 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 디커플된다.
        * 가시성은 OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.
        * 개발, 테스팅 및 운영 환경에 걸친 일관성 : 랩탑에서도 클라우드에서와 동일하게 구동된다.
        * 클라우드 및 OS 배포간 이식성 : Ubuntu, RHEL, CoreOS, on-perm, Google Kubernetes Engine 및 다른 어디에서든 구동된다.
        * 애플리케이션 중심 관리 : 가상 하드웨어의 OS에서 애플리케이션을 구동하는 수준에서 OS의 논리적인 자원을 사용하여 애플리케이션을 구동하는 수준으로 추상화 수준이 높아진다.
        * 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로 서비스 : 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.
        * 자원 격리 : 애플리케이션 성능을 예측할 수 있다.
        * 자원 사용량 : 고효율 고집적

#### 쿠버네티스가 왜 필요하고 무엇을 할 수 있나
* 컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다.
* 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다.
* 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다.
* 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까? 그것이 쿠버네티스가 필요한 이유이다.
* 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다.
* 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다.
* 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.
* 쿠버네티스가 제공하는 것들
* 서비스 디스커버리와 로드 밸런싱 : 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
* 스토리지 오케스트레이션 : 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
* 자동화된 롤아웃과 롤백 : 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
* 자동화된 빈 패킹(bin packing) : 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
* 자동화된 복구(self-healing) : 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
* 시크릿과 구성 관리 : 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이터 할 수 있다.

#### 쿠버네티스의 과거, 현재, 미래
* 쿠버네티스는 다른 컨테이너 오케스트레이션 도구보다 비교적 늦게 등장했다.
* 도커 스웜이 쉽고 간단한 사용법을 앞세워 세력을 넓히고 있었고 Mesos에서 Marathon을 발표했다.
* 컨테이너 오케스트레이션이 하는 일은 여러 개의 서버에 컨테이너를 배포하고 운영하면서 서비스 디스커버리(Service Discovery) 같은 기능을 이용하여 서비스 간 연결을 쉽게 해주는 것이다.
* 서버마다 app01, db01, cache01 같은 이름을 지어주고 하나하나 접속하여 관리하는 것이 아니라 server1,2,3,4 를 하나로 묶어 적당한 서버를 자동으로 선택해 애플리케이션을 배포하고 부하가 생기면 컨테이너를 늘리고 일부 서버에 장애가 발생하면 정상 동작 중인 서버에 다시 띄워 장애를 방지한다.

#### 쿠버네티스란?
* 쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다.
* 단순한 컨테이너 플랫폼이 아닌 마이크로 서비스, 클라우드 플랫폼을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 한다.
* 서버리스, CI/CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작한다.

#### 쿠버네티스 특징
* 컨테이너 오케스트레이션의 기본 기능 외에 쿠버네티스가 가지는 차별화된 특징
* 전 세계적 스케일의 경험과 기술이 고스란히 녹아들어 있다.
* 다양한 배포 방식
* 쿠버네티스는 Deployment, StatefulSets, DeamonSet, Job, CronJob 등 다양한 배포 방식을 지원한다.
* Deployment는 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포할 수 있다.
* StatefulSets은 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게 사용할 수 있어 순서나 데이터가 중요한 경우에 사용할 수 있다.
* 로그나 모니터링 등 모든 노드에 설치가 필요한 경우엔 DaemonSet을 이용하고 배치성 작업은 Job이나 CronJob을 이용하면 된다.

#### Ingress 설정
* 다양한 웹 애플리케이션을 하나의 로드 밸런서로 서비스하기 위해 Ingress 기능을 제공한다.
* 웹 애플리케이션을 배포하는 과정을 보면 외부에서 직접 접근할 수 없도록 애플리케이션을 내부망에 설치하고 외부에서 접근이 가능한 ALB나 Nginx, Apache를 프록시 서버로 활용한다.
* 프록시 서버는 도메인과 Path 조건에 따라 등록된 서버로 요청을 전달하는데 서버가 바뀌거나 IP가 변경되면 매번 설정을 수정해줘야 한다.
* 쿠버네티스의 Ingress는 이를 자동화하면서 기존 프록시 서버에서 사용하는 설정을 거의 그대로 사용할 수 있다.
* 새로운 도메인을 추가하거나 업로드 용량을 제한하기 위해 일일이 프록시 서버에 접속하여 설정할 필요가 없다.
* 하나의 클러스터에 여러 개의 Ingress 설정을 할 수 있어 관리자 접속용 Ingress와 일반 접속용 Ingress를 따로 관리할 수 있다.

#### 클라우드 지원
* 쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능(AutoScaling)이 있고 IP를 할당받아 로드밸런스(LoadBalancer)로 사용할 수 있다.
* 외부 스토리지를 컨테이너 내부 디렉토리에 마운트 하여 사용하는 것도 일반적인데 이를 위해 클라우드 별로 적절한 API를 사용하는 모듈이 필요하다.
* 쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있다.
* AWS, 구글 클라우드, 마이크로 소프트 애저는 물론 수십 개의 클라우드 업체에서 모듈을 제공하여 관리자는 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용할 수 있다.

#### Namespace & Label
* 하나의 클러스터를 논리적으로 구분하여 사용할 수 있다.
* 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본(system, default)외에 여러 개의 네임 스페이스를 사용하는 것이 일반적이다.
* 더 세부적인 설정으로 라벨 기능을 적극적으로 사용하여 유연하면서 확장성 있게 리소스를 관리할 수 있다.

#### RBAC(role-based access control)
* 접근 권한 시스템이다.
* 각각의 리소스에 대해 유저별로 CRUD 스런 권한을 손쉽게 지정할 수 있다.
* 클러스터 전체에 적용하거나 특정 네임스페이스에 적용할 수 있다.
* AWS의 경우 IAM을 연동해서 사용할 수도 있다.

#### 쿠버네티스 기본 개념
* 쿠버네티스에서 가장 중요한 것은 desired state - 원하는 상태 라는 개념이다.
* 원하는 상태라 함은 관리자가 바라는 환경을 의미하고 좀 더 구체적으로는 얼마나 많은 웹서버가 떠 있으면 좋은지, 몇 번 포트로 서비스하기를 원하는지 등을 말한다.
* 쿠버네티스는 복잡하고 다양한 작업을 하지만 자세히 들여다보면 현재 상태(current state)를 모니터링하면서 관리자가 설정한 원하는 상태를 유지하려고 내부적으로 이런저런 작업을 하는 단순한 로직을 가지고 있다.
* 이러한 개념 때문에 관리자가 서버를 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용한다.
* 쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지 알아야 한다.

#### Kubernetes Object
* 쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의한다.
* 기본적으로 수십 가지 오브젝트를 제공하고 새로운 오브젝트를 추가하기가 매우 쉽기 때문에 확장성이 좋다.

#### Pod
* 쿠버네티스에서 배포할 수 있는 가장 작은 단위로 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가진다.
* Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고 서로 로컬 호스트로 접근할 수 있다.
* 컨테이너를 하나만 사용하는 경우도 반드시 Pod으로 감싸서 관리한다.

#### ReplicaSet
* Pod을 여러 개(한 개 이상) 복제하여 관리하는 오브젝트이다.
* Pod을 생성하고 개수를 유지하려면 반드시 ReplicaSet을 사용해야 한다.
* ReplicaSet은 복제할 개수, 개수를 체크할 라벨 선택자, 생성할 Pod의 설정값(템플릿)등을 가지고 있다.
* 직접적으로 ReplicaSet을 사용하기보다는 Deployment등 다른 오브젝트에 의해서 사용되는 경우가 많다.

#### Service
* 네트워크와 관련된 오브젝트이다.
* Pod을 외부 네트워크와 연결해주고 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용한다.
* 내부 DNS에 서비스 이름을 도메인으로 등록하기 때문에 서비스 디스커버리 역할도 한다.

#### Volume
* 저장소와 관련된 오브젝트이다.
* 호스트 디렉토리를 그대로 사용할 수도 있고 EBS 같은 스토리지를 동적으로 생성하여 사용할 수도 있다.
* 사실상 인기 있는 대부분의 저장 방식을 지원한다.

#### Object Spec - YAML
* 오브젝트의 명세(Spec)는 YAML 파일(JSON도 가능하다고 하지만 잘 안 씀)로 정의하고 여기에 오브젝트의 종류와 원하는 상태를 입력한다.
* 이러한 명세는 생성, 조회, 삭제로 관리할 수 있기 때문에 REST API로 쉽게 노출할 수 있다.
* 접근 권한 설정도 같은 개념을 적용하여 누가 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있다.

#### 쿠버네티스 배포방식
* 쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 다양한 오브젝트(object)에 라벨(Label)을 붙여 정의(yaml)하고 API 서버에 전달하는 방식을 사용한다.

#### 쿠버네티스 아키텍처
* 컨테이너는 아주 심플하고 우아하게 동작한다.
* run을 하면 실행되고 stop을 하면 멈춘다.
* 서버 - 클라이언트 구조를 안다면 컨테이너를 관리하는 에이전트를 만들고 중앙에서 API를 이용하여 원격으로 관리하는 모습을 쉽게 그려볼 수 있다.
* 쿠버네티스 또한 중앙(Master)에 API 서버와 상태 저장소를 두고 각 서버(Node)의 에이전트(kubelet)와 통신하는 단순한 구조이다.

#### 마스터 - 노드 구조
* 쿠버네티스는 전체 클러스터를 관리하는 마스터와 컨테이너가 배포되는 노드로 구성되어 있다.
* 모든 명령은 마스터의 API 서버를 호출하고 노드는 마스터와 통신하면서 필요한 작업을 수행한다.
* 특정 노드의 컨테이너에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는게 아니라 마스터에 명령을 내리고 마스터가 노드에 접속하여 대신 결과를 응답한다.

#### Master
* 마스터 서버는 다양한 모듈이 확장성을 고려하여 기능별로 쪼개져 있는 것이 특징이다.
* 관리자만 접속할 수 있도록 보안 설정을 해야 하고 마스터 서버가 죽으면 클러스터를 관리 할 수 없기 때문에 보통 3대를 구성하여 안정성을 높인다.
* AWS EKS 같은 경우 마스터를 AWS에서 자체 관리하여 안정성을 높였고(마스터에 접속 불가) 개발 환경이나 소규모 환경에선 마스터와 노드를 분리하지 않고 같은 서버에 구성하기도 한다.

#### Node
* 노드 서버는 마스터 서버와 통신하면서 필요한 Pod을 생성하고 네트워크와 볼륨을 설정한다.
* 실제 콘테이너들이 생성되는 것으로 수백, 수천대로 확장할 수 있다.
* 각각의 서버에 라벨을 붙여 사용목적(GPU 특화, SSD 서버 등)을 정의할 수 있다.

#### Kubelet
* API 서버는 json 또는 protobuf 형식을 이용한 http 통신을 지원한다.
* 이 방식을 그대로 쓰면 불편하므로 보통 kubectl 이라는 명령행 도구를 사용한다.

#### Master 구성 요소
#### API 서버 kube-apiserver
* API 서버는 모든 요청을 처리하는 마스터의 핵심 모듈이다.
* kubectl의 요청뿐 아니라 내부 모듈의 요청도 처리하여 권한을 체크하여 요청을 거부할 수 있다.
* 실제로 하는 일은 원하는 상태를 key-value 저장소에 저장하고 저장된 상태를 조회하는 매우 단순한 작업이다.
* pod을 노드에 할당하고 상태를 체크하는 일은 다른 모듈로 분리되어 있다.
* 노드에서 실행 중인 컨테이너의 로그를 보여주고 명령을 보내는 등 디버거 역할도 수행한다.

#### 분산 데이터 저장소 etcd
* RAFT 알고리즘을 이용한 key-value 저장소이다.
* 여러 개로 분산하여 복제할 수 있기 때문에 안정성이 높고 속도도 빠른 편이다.
* 단순히 값을 저장하고 읽는 기능뿐 아니라 watch 기능이 있어 어떤 상태가 변경되면 바로 체크하여 로직을 실행할 수 있다.
* 클러스터의 모든 설정, 상태 데이터는 여기 저장되고 나머지 모듈은 stateless하게 동작하기 때문에 etcd만 잘 백업해두면 언제든지 클러스터를 복구할 수 있다.
* etcd는 오직 API 서버와 통신하고 다른 모듈은 API 서버를 거쳐 etcd 데이터에 접근한다.

#### 스케줄러, 컨트롤러
* API 서버는 요청을 받으면 etcd 저장소와 통신할 뿐 실제로 상태를 바꾸는 건 스케줄러와 컨트롤러이다.
* 현재 상태를 모니터링하다가 원하는 상태와 다르면 각자 맡은 작업을 수행하고 상태를 갱신한다.

#### 스케줄러 kube-scheduler
* 스케줄러는 할당되지 않은 po을 여러 가지 조건(필요한 자원, 라벨)에 따라 적절한 노드 서버에 할당해주는 모듈이다.

#### 큐브 컨트롤러 kube-controller-manager
* 큐브 컨트롤러는 다양한 역할을 하는 아주 바쁜 모듈이다.
* 쿠버네티스에 있는 거의 모든 오브젝트의 상태를 관리한다.
* 오브젝트별로 철저하게 분업화되어 Deployment는 ReplicSet을 생성하고 ReplicaSet은 Pod을 생성하고 Pod은 스케줄러가 관리하는 식이다.

#### 클라우드 컨트롤러 cloud-controller-manager
* 클라우드 컨트롤러는 AWS, GCE, Azure 등 클라우드에 특화된 모듈이다.
* 노드를 추가/삭제하고 로드 밸런서를 연결하거나 볼륨을 붙일 수 있다.
* 각 클라우드 업체에서 인터페이스에 맞춰 구현하면 되기 때문에 확장성이 좋고 많은 곳에서 자체 모듈을 만들어 제공하고 있다.

#### Node 구성 요소
#### 큐블릿 kubelet
* 노드에 할당된 pod의 생명주기를 관리한다.
* pod을 생성하고 pod 안의 컨테이너에 이상이 없는지 확인하면서 주기적으로 마스터에 상태를 전달한다.
* API 서버의 요청을 받아 컨테이너의 로그를 전달하거나 특정 명령을 대신 수행하기도 한다.

#### 프록시 kube-proxy
* 큐블릿이 pod를 관리한다면 프록시는 pod으로 연결되는 네트워크를 관리한다.
* TCP, UDP, SCTP 스트림을 포워딩하고 여러 개의 pod을 라운드로빈 형태로 묶어 서비스를 제공할 수 있다.
* 초기에는 kube-proxy 자체가 프록시 서버로 동작하면서 실제 요청을 프록시 서버가 받고 각 pod에 전달해 주었는데 시간이 지나면서 iptables를 설정하는 방식으로 변경되었다.
* iptables에 등록된 규칙이 많아지면 느려지는 문제 때문에 최근 IPVS를 지원하기 시작했다.

#### 추상화
* 컨테이너는 도커고 도커가 컨테이너라고 생각해도 무리가 없는 상황이지만 쿠버네티스는 CRI(Container runtime interface)를 구현한 다양한 컨테이너 런타임을 지원한다.

#### 하나의 Pod이 생성되는 과정
* 관리자가 애플리케이션을 배포하기 위해 ReplicaSet을 생성하면 다음과 같은 과정을 거쳐 Pod을 생성한다.
1. API Server : ReplicaSet 생성
2. Controller -> API Server : 생성 요청 감시
3. Controller -> API Server : Pod 생성 요청
4. Scheduler -> API Server : Pod 생성 요청 감시
5. Scheduler -> API Server : 노드에 Pod 할당
6. Kubelet -> API Server : Pod 할당 감시
7. Kubelet -> Docker : 컨테이너 생성
8. Kubelet -> API Server : Pod 상태 업데이트
* 흐름을 보면 각 모듈은 서로 통신하지 않고 오직 API Server와 통신하는 것을 알 수 있다.
* API Server를 통해 etcd에 저장된 상태를 체크하고 현재 상태와 원하는 상태가 다르면 필요한 작업을 수행한다.
* 각 모듈이 하는 일
    * kubectl
        * ReplicaSet 명세를 yml 파일로 정의하고 kubectl 도구를 이용하여 API Server에 명령을 전달
        * API Server는 새로운 ReplicaSet Object를 etcd에 저장
    * Kube Controller
        * Kube Controller에 포함된 ReplicaSet Controller가 ReplicaSet을 감시하다가 ReplicaSet에 정의된 Label Selector 조건을 만족하는 Pod이 존재하는지 체크
        * 해당하는 Label의 Pod이 없으면 ReplicaSet의 Pod 템플릿을 보고 새로운 Pod을 생성
        * 생성은 역시 API Server에 전달하고 API Server는 etcd에 저장
    * Scheduler
        * Scheduler는 할당되지 않은 pod이 있는지 체크
        * 할당되지 않은 pod이 있으면 조건에 맞는 Node를 찾아 해당 pod을 할당
    * Kubelet
        * kubelet은 자신의 Node에 할당되었지만 아직 생성되지 않은 Pod이 있는지 체크
        * 생성되지 않은 Pod이 있으면 명세를 보고 Pod을 생성
        * Pod의 상태를 주기적으로 API Server에 전달

#### 참고
* https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/
* https://subicura.com/2019/05/19/kubernetes-basic-1.html