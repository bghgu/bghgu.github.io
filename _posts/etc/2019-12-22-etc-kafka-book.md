---
layout: post
title:  "카프카 책 정리"
date:   2019-12-22 13:00:00
author: bghgu
categories: etc
tags: [etc]
---

#### 들어가며
* 대용량, 대규모 메시지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼
* 빅데이터를 분석할 때 여러 스토리지와 분석 시스템에 데이터를 연결하기 위한 필수 도구로 인식되었다.
* 글로벌 기업들에서 데이터 파이프라인으로 매우 중요하게 사용되고 있다.

#### 카프카 탄생 배경
* 링크드인에서 처음 출발한 기술이다. 링크드인이 성장하면서 발생하는 내부 여러 이슈들을 해결하기 위해 탄생했다.
* 엔드 투 엔드(end-to-end) 연결 방식의 아키텍처는 많은 문제점이 있다.
1. 실시간 트랜잭션(OLTP) 처리와 비동기 처리가 동시에 이뤄지지만 통합된 전송 영역이 없으니 복잡도가 증가한다.
   * 문제를 발견하고 조치를 취하려면 이와 관련된 데이터 시스템을 확인해야 한다.
   * 장애나 운영체제 업그레이드, 하드웨어 증설과 같은 작업을 위해서도 역시 아주 많은 준비 시간이 필요하다.
2. 데이터 파이프라인 관리의 어려움이 있다.
   * 실시간 트랜잭션 데이터베이스, 아파치 하둡, 모니터링 시스템, 키-값 저장소 등 많은 데이터 시스템들이 있는데, 이 시스템에 저장된 동일한 데이터를 개발자나 개발 부서는 각기 다른 방법으로 파이프 라인을 만들고 유지하게 되었다.
   * 처음에는 각자의 목적에 맞게 만들어서 간편했지만, 시간이 지나면서 이 데이터 파이프라인들은 통합 데이터 분석을 위해 서로 연결되어야 하는 일들이 필연적으로 발생한다.
   * 하지만 각 파이프라인별로 데이터 포맷과 처리하는 방법들이 완전히 달라서 데이터 파이프라인은 확장하기 어렵다.
   * 이러한 데이터 파이프라인들을 조정하고 운영하는 것은 엄청난 노력이 필요했다.
   * 복잡성으로 인해 두 시스템 간의 데이터가 서로 달라져 데이터의 신뢰도마저 낮아졌다.
* 복잡도가 늘고 파이프라인이 파편화되면서 개발이 지연되고 데이터를 신뢰 할 수 없는 상황에 이르자, 모든 시스템으로 데이터를 전송할 수 있고, 실시간 처리도 가능하며, 급속도로 성장하는 서비스를 위해 확장이 용이한 시스템을 만들었다.
* 다음과 같은 목표를 가지고 카프카를 만들었다.
    * 프로듀서와 컨슈머의 분리
    * 메시징 시스템과 같이 영구 메시지 데이터를 여러 컨슈머에게 허용
    * 높은 처리량을 위한 메시지 최적화
    * 데이터가 증가함에 따라 스케일아웃이 가능한 시스템
* 사내에서 발생하는 모든 이벤트/데이터의 흐름을 중앙에서 관리하는 카프카를 적용한 결과, 서비스 아키텍처가 예전과 비교할 수 없을 정도로 매우 깔끔해졌다.
* 카프카가 전사 데이터 파이프라인으로 동작하기 때문에 모든 데이터 스토어와 여기서 발생하는 데이터/이벤트가 카프카를 중심으로 연결되어 있다.
* 기존 데이터 스토어가 그대로 있을 뿐만 아니라, 새로운 데이터 스토어가 들어와도 서로 카프카가 제공하는 표준 포맷으로 연결되어 있어서 데이터를 주고받는 데 부담이 없다.
* 그래서 더욱 상세하고 다양한 데이터를 분석해서 더 좋은 서비스를 제공할 수 있게 되었다.
* 이전에는 할 수 없었던 다양한 분석이 가능해져 신뢰성 높은 데이터 분석 뿐만 아니라 실시간 분석까지 할 수 있게 되어 서비스의 품질이 몇 단계 이상 높아질 수 있는 형태로 바뀌었다.
* 개발 입장에서도 이전에는 데이터 스토어 백엔드 관리와 백엔드에 따른 포맷, 별도의 앱 개발을 해야 했는데 이젠 카프카에만 데이터를 전달하면 나머지는 필요한 곳 또는 다른 서비스들이 각자 가져갈 수 있어서 본연의 업무에만 집중할 수 있게 되었다.
* 카프카를 메시지 전달의 중앙 플랫폼으로 두고 기업에서 필요한 모든 데이터 시스템뿐만 아니라 마이크로서비스, SaaS 서비스 등과 연결된 파이프라인을 만드는 것을 목표로 두고 개발되었다.

#### 메시징 시스템
* 

#### 카프카의 동작 방식과 원리
* 카프카는 기본적으로 메시징 서버로 동작한다.
* 메시지라고 불리는 데이터 단위를 보내는 측(퍼블리셔 publisher 또는 프로듀서 producer)에서 카프카에 토픽이라는 각각의 메시지 저장소에 저장하면, 가져가는 측(서브스크라이버 subscriber 또는 컨슈머 consumer)이 원하는 토픽에서 데이터를 가져가게 되어있다.
* 중앙에 메시징 시스템 서버를 두고 이렇게 메시지를 보내고(publish) 받는(subscribe) 형태의 통신을 펍/섭(pub/sub) 모델이라고 한다.

#### 일반적인 통신 모델
* 프로듀서와 컨슈머가 직접 통신하는 방식이다.
* 빠른 전송 속도와 전송 결과를 신속하게 알 수 있는 장점이 있다.
* 특정 개체에 장애가 발생한 경우 메시지를 보내는 쪽에서 대기 처리 등을 개별적으로 해주지 않으면 장애가 발생할 수 있다.
* 일반적 형태의 통신의 경우 통신에 참여하는 개체가 많아질수록 서로 일일이 다 연결을 하고 데이터를 전송해야 하기 때문에 확장성이 좋지 않다.
* 이런 형태의 단점을 극복하고자 나온 통신 모델이 펍/섭 모델이다.

#### 펍/섭(pub/sub) 모델
* 비동기 메시징 전송 방식이다.
* 바신자의 메시지에는 수신자가 정해져 있지 않은 상태로 발생(publish)한다.
* 구독(subscribe)을 신청한 수신자만이 정해진 메시지를 받을 수 있다.
* 또한 수신자는 발신자 정보가 없어도 원하는 메시지만을 수신할 수 있다.
* 이러한 구조 덕분에 다이나믹한 네트워크 토플로지와 높은 확장성을 확보할 수 있다.

#### 펍/섭(pub/sub) 모델 작동 방식
* 프로듀서가 메시지를 컨슈머에게 직접 전달하는게 아니라 중간의 메시징 시스템에 전달한다.
* 이때 메시지 데이터와 수신처 ID를 포함시킨다.
* 메시징 시스템의 교환기가 메시지의 수신처 ID값을 확인한 다음 컨슈머들의 큐에 전달된다.
* 컨슈머는 자신들의 큐를 모니터링하고 있다가, 큐에 메시지가 전달되면 이 값을 가져간다.
* 이렇게 구성할 경우 장점은 혹시나 개체가 하나 빠지거나 수신 불능 상태가 되었을 때에도, 메시징 시스템만 살아 있으면 프로듀서에서 전달된 메시지가 유실되지 않는다.
* 이 메시지는 불능 상태의 개체가 다시 회복되면 언제든지 다시 가져갈 수 있다.
* 각각의 개체가 다대다 통신을 하는것이 아니라 메시징 시스템을 중심으로 연결되기 때문에 확장성이 용이하다.
* 사용자나 어드민이 연결을 직접 관장하는 것이 아니라, 교환기의 룰에 의해서 데이터가 수신처의 큐에 정확하게 전달되므로 메시지 데이터 유실의 염려가 없다.
* 펍/섭의 단점은 직접 통신을 하지 않기 때문에 메시지가 정확하게 전달되었는지 확인하려면 코드가 좀 더 복잡해지고, 중간에 메시징 시스템이 있기 때문에 메시지 전달 속도가 빠르지 않다.

#### 
* 기존 시스템을 이용하는 펍/섭 모델은 대규모 데이터를 메시징 시스템에 전달하기보다는 간단한 이벤트를 서버로 전송하는데 주로 사용되었다.
* 왜냐하면 메시징 시스템 내부의 교환기의 부하, 각 컨슈머들의 큐 관리, 큐에 전달되고 가져가는 메시지의 정합성, 전달 결과를 정확하게 관리하기 위한 내부 프로세스가 아주 다양하고 복잡하기 때문이다.
* 즉 기존의 메시징 시스템은 메시지의 보관, 교환, 전달 과정에서 신뢰성을 보장하는 것에 중점을 맞췄기 때문에 속도와 용량은 그렇게 중요하지 않았다.
* 그래서 회사나 조직 그리고 시스템 내의 데이터를 모으고 전달하기 위해서는 메시징 시스템이 절실하게 필요함에도 불구하고, 이것을 실제로 만드는 데는 항상 성능이 문제가 되어서 일부 컴포넌트나 원격 통신밖에 적용되지 못했다.
* 카프카는 메시징 시스템이 지닌 성능의 단점을 극복하기 위해, 메시지 교환 전달의 신뢰성 관리를 프로듀서와 컨슈머 쪽으로 넘기고, 부하가 많이 걸리는 교환기 기능 역시 컨슈머가 만들 수 잇게 함으로써 메시징 시스템 내에서의 작업량은 줄이고 이렇게 절약한 작업량을 메시징 전달 성능에 집중시켜서 고성능 메시징 시스템을 만들어냈다.

#### 카프카의 메시지 전달 순서
1. 프로듀서는 새로운 메시지를 카프카로 보낸다.
2. 프로듀서가 보낸 메시지는 카프카에 컨슈머 큐(토픽)에 도착해 저장된다.
3. 컨슈머는 카프카 서버에 접속하여 새로운 메시지를 가져간다.

#### 
* 카프카 역시 기존 메시징 시스템과 동일한 비동기 시스템이다.
* 프로듀서는 컨슈머와 관계없이 새로운 메시지를 카프카로 전송하고, 컨슈머 역시 프로듀서와 관계없이 카프카에서 새로운 메시지를 가져온다.
* 프로듀서와 컨슈머는 각자의 역할이 정확히 구분되어 있다.
* 카프카에서도 수많은 메시지들이 저장되고, 그 메시지들은 토픽이라는 식별자를 이용해 토픽 단위로 저장되고 있다.
* 비동기 기반으로 메시지를 전달하는 대표적인 솔루션이 메시지 큐 솔루션이다.

#### 카프카의 특징

##### 프로듀서와 컨슈머의 분리
* 링크드인에서는 메트릭 수집 방식을 폴링 방식으로 구현된 시스템을 사용했고, 메트릭 수집이 늦어지는 경우가 발생하면서 수집이나 처리 시간이 너무 늦어지는 문제점이 발견되었다.
* 이에 대한 해결 방법으로 데이터를 보내는 역할과 받는 역할을 완벽하게 분리하기를 원했다.
* 카프카는 메시징 전송 방식 중 메시지를 보내는 역할과 받는 역할이 완벽하게 분리된 펍/섭 방식을 적용했다.
* 펍/섭 방식인 카프카를 중앙에 놓으면 한눈에 보기에도 구조가 매우 단순해진다.
* 각각의 서비스들은 모니터링이나 분석 시스템의 상태 유무와 관계없이 카프카로 메시지를 보내는 역할만 하면 되고, 마친가지로 모니터링이나 분석 시스템들도 서비스 서버들의 상태 유무와 관계없이 카프카에 저장되어 있는 메시지만 가져오면 된다.
* 이렇게 각자의 역할이 완벽하게 분리되면서, 어느 한쪽 시스템에서 문제가 발생하더라도 연쇄작용이 발생할 확률은 매우 낮다.
* 또한 웹 서버가 추가되더라도 카프카로만 보내면 되기 때문에 서버 추가에 대한 부담도 줄일 수 있는 장점이 있다.

##### 멀티 프로듀서, 멀티 컨슈머
* 카프카는 하나의 토픽에 여러 프로듀서 또는 컨슈머들이 접근 가능한 구조로 되어있다.
* 하나의 프로듀서가 하나의 토픽에만 메시지를 보내는 것이 아니라, 하나 또는 하나 이상의 토픽으로 메시지를 보낼 수 있다.
* 컨슈머 역시 하나의 토픽에서만 메시지를 가져오는 것이 아니라, 하나 또는 하나 이상의 토픽으로부터 메시지를 가져올 수 있다.
* 멀티 기능은 데이터 분석 및 처리 프로세스에서 하나의 데이터를 다양한 용도로 사용하는 요구가 많아지기 시작했고, 이러한 요구 사항들을 손쉽게 충족할 수 있다.
* 멀티 프로듀서와 컨슈머를 구성할 수 있기 때문에 카프카는 중앙 집중형 구조로 구성할 수 있게 되었다.

##### 디스크에 메시지 저장
* 카프카가 기존의 메시징 시스템과 가장 다른 특징 중 하나는 바로 디스크에 메시지를 저장하고 유지하는 것이다.
* 일반적인 메시징 시스템들은 컨슈머가 메시지를 읽어가면 큐에서 바로 메시지를 삭제한다.
* 카프카는 컨슈머가 메시지를 읽어 가더라도 정해져 있는 보관 주기 동안 디스크에 메시지를 저장해둔다.
* 트래픽이 일시적으로 폭주해 컨슈머의 처리가 늦어지더라도 카프카의 디스크에 안전하게 보관되어 있기 때문에, 컨슈머는 메시지 손실 없이 메시지를 가져갈 수 있다.
* 멀티 컨슈머도 카프카에 메시지들이 디스크로 저장되어 있기 때문에 가능한 것이다.
* 컨슈머에 버그가 있어 오류가 발생했다면, 컨슈머를 잠시 중단하고 버그를 찾아 해결한 후 컨슈머를 다시 실행할 수 있다.
* 이러한 방법으로 작업하더라도 메시지가 디스크에 저장되어 있기 때문에 메시지 손실 없이 작업이 가능하다.

##### 확장성
* 카프카는 확장이 매우 용이하도록 설계되어 있다.
* 하나의 카프카 클러스터는 3대의 브로커로 시작해 수십 대의 브로커로 확장 가능하다.
* 확장 작업은 카프카 서비스의 중단 없이 온라인 상태에서 작업이 가능하다.
* 최초 카프카 클러스터 구성시 적은 수로 시작하더라도 이후 트래픽 및 사용량 증가로 클러스터를 확장하는 작업은 매우 간단할 뿐만 아니라, 큰 부담 없이 할 수 있다.

##### 높은 성능
* 카프카는 매우 높은 성능을 목표로 탄생한 애플리케이션이다.
* 고성능을 유지하기 위해 카프카는 내부적으로 분산 처리, 배치 처리 등 다양한 기법을 사용하고 있습니다.
  
#### 카프카의 용어 정리
* 카프카(Kafka) : 아파치 프로젝트 애플리케이션 이름이다. 클러스터 구성이 가능하며, 카프카 클러스라고 부른다.
* 브로커(Broker) : 카프카 애플리케이션이 설치되어 있는 서버 또는 노드를 말한다.
* 토픽(Topic) : 프로듀서와 컨슈머들이 카프카로 보낸 자신들의 메시지를 구분하기 위한 네임으로 사용한다. 많은 수의 프로듀서, 컨슈머들이 동일한 카프카를 이용하게 된다면, 메시지들이 서로 뒤섞여 각자 원하는 메시지를 얻기가 어렵게 된다. 그래서 토픽이라는 이름으로 구분하여 사용하게 된다.
* 파티션(Partition) : 병렬처리가 가능하도록 토픽을 나눌 수 있고, 많은 양의 메시지 처리를 위해 파티션의 수를 늘려줄 수 있다.
* 프로듀서(Producer) : 메시지를 생산하여 브로커의 토픽 이름으로 보내는 서버 또는 애플리케이션 등을 말한다.
* 컨슈머(Consumer) : 브로커의 토픽 이름으로 저장된 메시지를 가져가는 서버 또는 애플리케이션 등을 말한다.

#### 카프카의 확장과 발전
* 카프카를 통한 고성능의 펍/섭 모델이 가능해지면서 2000년대 초에 등장했던 서비스 기반 아키텍처(SOA, Service Oriented Architecture)의 핵심 구성요소 중 하나인 엔터프라이즈 서비스 버스(ESB, Enterprise Service Bus)를 쉽게 구현할 수 있게 되었습니다.
* SOA는 업무를 서비스라는 단위로 쪼개고, 각 서비스 간의 연결은 ESB를 통해 연결한다는 철학을 지향했다.
* ESB의 특징
    * 다양한 시스템과 연동하기 위한 멀티 프로토콜과 데이터 타입 지원
    * 느슨한 결합(Loosely coupled)을 위한 메시지 큐 지원
    * 정기적으로 데이터를 가져오는 대신 이벤트 기반(Event Driven) 통신 지향
* 카프카를 통해 ESB, 메시지 버스, 이벤트 버스 등과 같이 기업 내 데이터 흐름을 중앙에서 관리하는 많은 사례들이 생겨나고 있다.
* 현재는 기업 내 데이터 버스로뿐만 아니라 플러그인을 통해 외부 데이터를 가져와서 기업 내에서 활용할 수 있게 한다.
* 회사 내의 기존 메시징 시스템도 브릿지를 연결해서 사용하는 형태로 발전했다.
* 퍼블릭 클라우드와 같이 기업 외부에 있는 데이터 센터의 로깅/미터링/이벤트 데이터를 연결해서 가지고 올 수 있게 해서, 말 그대로 필요한 모든 데이터가 연결되어 서로 가져갈 수 있는 형태로 발전하고 있다.
* 마침내 카프카는 빅데이터 분석과 머신러닝 플랫폼을 만드는 데 아주 중요한 요소로 자리잡게 되었다.
* 이제는 강력한 메시지 전달 능력을 바탕으로, 단순히 메시징을 연결해주는 역할을 넘어서 실제로 실시간 분석까지 할 수 있는 카프카 스트림즈, KSQL 등 분석 시스템으로 진화하면서 말 그대로 메시징 플랫폼의 최강자가 되어 가고 있다.
* 기존에 아파치 스톰(Storm)이나 스파크(Spark)로 구성된 실시간 분석 플랫폼에 하둡을 활용한 배치 분석 플랫폼과도 연결할 수 있다.
* 다만, 스파크나 스톰은 대규모 시스템을 관리해줄 엔지니어가 별도로 있어야 하는데, 이런 단점을 극복하기 위해서 간단히 스트림 처리 앱을 개발할 수 있는 카프카 스트림즈와 SQL기반으로 데이터를 분석할 수 있게 해주는 KSQL을 통해 실시간 데이터 분석에 있어서도 주요한 부분을 담당하도록 발전하고 있다.
* 오늘날 카프카는 단순한 메시지 큐의 기능을 넘어 많은 기업의 비즈니스 확장 요구에 맞춰 기업 내 중요 시스템 중의 하나로 널리 사용되고 있다.

#### Zookeeper 주키퍼
* 현재까지의 카프카 버전에서는 오프셋 정보를 주키퍼와 카프카 양쪽에 저장할 수 있지만, 향후 주키퍼에 오프셋을 저장하는 기능은 사라질 예정이다.
* 주키퍼는 컨슈머와 통신하는 부분 외에도 카프카와 직접 통신을 하면서, 카프카의 메타데이터 정보를 주키퍼에 저장하고, 카프카의 상태관리 등의 목적으로 주키퍼를 이용한다.
* 카프카는 주키퍼와 긴밀하게 통신하기 때문에 주키퍼 사용이 필수 조건이다.
* 주키퍼는 카프카 패키지에 포함되어 있는 주키퍼를 사용할 수도 있고, 주키퍼 역시 아파치 오픈소스 중 하나이므로 별개의 주키퍼를 내려받아 사용할 수 있다.
* 