---
layout: post
title:  "가상 메모리 & 단편화 & 페이징 & 세그먼트 & 메모리 풀"
date:   2020-01-16 18:55:00
author: bghgu
categories: OS
tags: [OS]
---

#### Virtual Memory 가상 메모리
* 한정된 메모리 공간에 메모리 공간보다 더 큰 프로세스를 실행하기 위해 등장한 기법이다.
* 보조 기억 장치(하드디스크)의 일부를 주 기억 장치처럼 사용하는 것으로, 용량이 작은 주 기억 장치를 마치 큰 용량을 가진 것 처럼 사용하는 기법이다.
* 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주 기억장치에 불연속적으로 할당하여 처리한다.
* 주 기억방치의 용량보다 큰 프로그램을 실행하기 위해 사용한다.
* 주 기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
* 프로세스의 모든 코드는 항상 필요한 것이 아니다.
* 프로세스는 필요한 부분만 메모리에 적재함으로써 메인 메모리가 올라가는 프로세스의 크기를 줄일 수 있다.
* 동적 적재와 비슷한 개념이다.
* 가상 메모리는 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식이다.
* 가상 주소를 실제 주소로 변환해주는 Mapping은 MMU라는 하드웨어에 의해 지원된다.
* MMU(Memory Management Unit) : MMU는 메모리를 효율적으로 관리할 수 있도록 여러 가지 기능을 하드웨어로 구현한 반도체 칩이다. CPU와 메모리의 중간에 위치하여 프로그램에서 사용되는 가상주소를 메모리에 해당하는 물리적 주소로 변환하는 작업을 수행한다.
* Mapping 방식은 Paging, Segmentation, 두 가지를 합한 방식, 총 3가지가 있다.
* 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생하는 단편화를 해결할 수 있다.

#### Memory Fragmentation 메모리 단편화
* RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 메모리 단편화가 발생했다고 한다.
* 내부 단편화와 외부 단편화로 나뉜다.

#### Internal Fragmentation 내부 단편화
* 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황이다.
* OS가 4kb를 할당해줬지만 사실상 1kb만 사용하고 있을 때 필요 이상으로 프로세스가 메모리를 할당받았으므로 내부 단편화가 3kb만큼 생긴 것이다.

#### External Fragmentation 외부 단편화
* 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다.
* 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이다.
* 메모리 처음 주소에 8mb짜리 프로세스가 할당되었고 바로 이어서 16mb짜리 프로세스가 할당되었다고 가정했을 때 8mb짜리 프로세스를 종료시키면 메모리 처음 주소부터 8mb만큼 공간이 생긴다.
* 이런 식으로 계속해서 빈 메모리가 쌓이는데 빈 메모리의 공간 중에 제일 큰 빈 메모리가 8mb라고 한다면 9mb짜리 프로세스를 할당을 해야 할 때 마땅한 공간은 없지만 전체적으로 메모리 여유는 있을 때 외부 단편화가 생겼다고 한다.

#### Paging 페이징 기법
* 가상 메모리를 사용한다.
* 외부 단편화를 해결한다.
* 내부 단편화가 존재한다.
* 보조 기억 장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 정의한다.
* 페이지는 물리적 단위이다.
* RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 한다.
* 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법이다.
* 페이지와 프레임을 대응시키기 위해 Page Mapping 과정이 필요해서 Page Table을 만든다.
* 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있으므로 외부 단편화 문제를 해결할 수 있다.
* 페이지 단위에 알맞게 꽉 채워 쓰는 것이 아니므로 내부 단편화 문제는 여전히 존재한다.
* 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있겠지만, 대신 Page Mapping 과정이 많아지므로 오히려 효율이 떨어질 수도 있다.
* 페이징은 일정한 크기로 나눠서 메모리를 관리한다.
* 이미 일정한 크기로 잘려있는 식빵 조각

#### Segmentation 세그먼트 기법
* 가상 메모리를 사용한다.
* 내부 단편화를 해결한다.
* 외부 단편화가 존재한다.
* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 나누어 메모리를 할당하여 실제 메모리 주소로 변환하게 된다.
* 세그먼트는 논리적 단위이다.
* 각 세그먼트는 연속적인 공간에 저장되어 있다.
* 세그먼트들의 크기가 다르므로 미리 나눠 둘 수 없고, 메모리에 적재될 때 공간을 찾아 할당하는 기법이다.
* Mapping을 위해 세그먼트 테이블이 필요하다.
* 프로세스가 필요한 만큼 할당해주기 때문에 내부 단편화는 일어나지 않으나, 여전히 프로세스가 메모리를 해제할 때 발생하는 외부 단편화는 존재한다.
* 세그멘테이션은 필요한 만큼 메모리를 나눠서 관리한다.
* 케이크를 먹을 크기만큼 자를 때

#### Memory Pool 메모리 풀
* 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법이다.
* 메모리 풀 없이 동적 할당과 해제를 반복하면 메모리의 랜덤한 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.
* 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.
* 하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.
* 메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다.
* 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해 놓으므로 메모리 누수가 있는 방식이다.
* 구현 방법
- 큰 메모리 블록(페이지)을 힙으로부터 할당
- 할당 받은 페이지를 각 객체의 크기의 블록으로 나눔
- 각 객체를 위한 블록을 순차적으로 링크
- 이때 현 시점에서 할당할 블록을 특정 포인터가 가리키게 함
- 메모리 요청이 생기면 현재 헤더 포인터가 가리키는 블록을 돌려준다.
- 할당이 일어난 후 헤더 포인터는 할당 직전에 가리키던 블럭이 가리키던 블록을 가리킨다.
- 사용되던 메모리가 해제되어 메모리 풀로 돌아올 경우 헤더 포인터는 그 블록을 가리키고 방금 전까지 헤더 포인터가 가리키던 블록을 돌아온 블록의 다음 포인터가 가리키게 한다.